% !TeX spellcheck = it_IT
% !TeX root = thesis-main.tex
\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[italian]{babel}
\usepackage[hyperfootnotes=false]{hyperref}
\usepackage{disi-thesis}
\usepackage[acronym,toc]{glossaries}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{float}
\usepackage{pgfplots}

\tolerance=1000
\pgfplotsset{compat=1.18}


% Package per disegnare directories
\usepackage[edges]{forest}
\definecolor{folderbg}{RGB}{124,166,198}
\definecolor{folderborder}{RGB}{110,144,169}
\newlength\Size
\setlength\Size{4pt}
\tikzset{
	% setta immagine della cartella
	folder/.pic={%
		\filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.05*\Size,0.2\Size+5pt) rectangle ++(.75*\Size,-0.2\Size-5pt);
		\filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.15*\Size,-\Size) rectangle (1.15*\Size,\Size);
	},
	% setta immagine file
	file/.pic={%
		\filldraw [draw=folderborder, top color=folderbg!5, bottom color=folderbg!10] (-\Size,.4*\Size+5pt) coordinate (a) |- (\Size,-1.2*\Size) coordinate (b) -- ++(0,1.6*\Size) coordinate (c) -- ++(-5pt,5pt) coordinate (d) -- cycle (d) |- (c) ;
	},
}
\forestset{%
	declare autowrapped toks={pic me}{},
	declare boolean register={pic root},
	pic root=0,
	pic dir tree/.style={%
		for tree={%
			folder,
			font=\ttfamily,
			grow'=0,
		},
		before typesetting nodes={%
			for tree={%
				edge label+/.option={pic me},
			},
			if pic root={
				tikz+={
					\pic at ([xshift=\Size].west) {folder};
				},
				align={l}
			}{},
		},
	},
	pic me set/.code n args=2{%
		\forestset{%
			#1/.style={%
				inner xsep=2\Size,
				pic me={pic {#2}},
			}
		}
	},
	pic me set={directory}{folder},
	pic me set={file}{file},
}
% Fine configurazione package forest

\newcommand{\acknowledgementsname}{Riconoscimenti}
\renewcommand{\chaptername}{Capitolo} % Per i capitoli
\renewcommand{\bibname}{Bibliografia} % Per la bibliografia
\renewcommand{\contentsname}{Indice}  % Per il sommario
\renewcommand{\listfigurename}{Elenco delle figure}
\renewcommand{\listtablename}{Elenco delle tabelle}
\newcommand{\itemdef}[1]{\item \textbf{#1}}
\newcommand{\class}[1]{\texttt{#1}}
\newcommand{\cs}{C\# }

\glsdisablehyper

\pagenumbering{roman}



\school{\unibo}
\programme{Corso di Laurea in Ingegneria e Scienze Informatiche}
\title{ClientShield: Implementazione di un Servizio Windows per la Sicurezza DNS}
\author{Federico Diotallevi}
\date{\today}
\subject{Programmazione ad Oggetti}
\supervisor{Prof.\ Viroli Mirko}
%\cosupervisor{Nicolas Farabegoli}
\session{IV}
\academicyear{2023\ -\ 2024}

\newacronym{DoH}{DoH}{DNS over HTTPS}
\newacronym{DoT}{DoT}{DNS over TLS}
\newacronym{DNS}{DNS}{Domain Name System}
\newacronym{AI}{AI}{Intelligenza Artificiale}
\newacronym{PoC}{PoC}{Proof of Concept}
\newacronym{AGID}{AGID}{Agenzia per l'Italia Digitale}
\newacronym{VPN}{VPN}{Virtual Private Network}
\newacronym{HTTPS}{HTTPS}{HTTP Secure}
\newacronym{ISP}{ISP}{Internet Service Provider}
\newacronym{OS}{OS}{Sistema Operativo}
\newacronym{SRP}{SRP}{Single Responsibility Principle}
\newacronym{MVP}{MVP}{Model-View-Presenter}
\newacronym{MVC}{MVC}{Model-View-Controller}
\newacronym{WPF}{WPF}{Windows Presentation Foundation}
\newacronym{IDE}{IDE}{ambiente di sviluppo integrato}


\mainlinespacing{1.241} % line spacing in mainmatter, comment to default (1)

\begin{document}

\frontmatter\frontispiece\

\renewcommand{\abstractname}{Sommario}
\begin{abstract}

Lo sviluppo della tecnologia cresce sempre più velocemente e, con essa, anche i rischi che gli utenti corrono semplicemente navigando in rete.
Questa tesi si inserisce nell'ambito dell'internet filtering, cioè la possibilità di filtrare il traffico in rete negando l'accesso a siti potenzialmente pericolosi.

L'obiettivo di questo progetto è lo sviluppo di un software che sia facilmente installabile su un dispositivo Windows e filtri tutte le richieste web effettuate.
Si vuole offrire la possibilità ad un un amministratore di rete di attivare e disattivare la protezione del dispositivo da remoto, decidendo eventualmente anche quali categorie di siti bloccare.

Per lo sviluppo è stata fondamentale la collaborazione con FlashStart, azienda di riferimento nel mercato italiano per quanto riguarda il filtraggio \gls{DNS}.

Il software è stato sviluppato in contesto aziendale come prototipo e sfrutta ampiamente le soluzioni di filtraggio aziendali.
Ciò ha facilitato la gestione delle categorie e dell'effettivo filtraggio \gls{DNS}, permettendo al progetto di focalizzarsi sulla cattura e redirezione del traffico internet del dispositivo verso i server gestiti da FlashStart.
\end{abstract}

\begin{dedication}
Optional dedication.
\end{dedication}

%----------------------------------------------------------------------------------------
\tableofcontents   
%\listoffigures     % (optional) comment if empty
%\lstlistoflistings\ % (optional) comment if empty
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------

%---------------------------------------------------
% INTRODUZIONE
%---------------------------------------------------

\chapterWithoutNumber{Introduzione}
\phantom{Introduzione}
\label{chap:introduzione}
%----------------------------------------------------------------------------------------

Navigare in rete è senz'altro una delle attività più diffuse al giorno d'oggi in tutto il mondo.
La quantità di informazioni a cui si può accedere è pressoché infinita e, soprattutto, a disposizione di chiunque.

La digitalizzazione delle risorse è ormai diventata essenziale per qualsiasi realtà, dal settore pubblico a quello privato.
Tuttavia, tale pratica espone inevitabilmente al rischio che documenti,
dati e informazioni sensibili diventino obiettivo di attacchi informatici.
A conferma di ciò, il recente rapporto \cite{clusit2024-sicurezza} evidenzia come gli attacchi informatici gravi a livello globale siano passati,
in media, da 4.5 a 9 al giorno in soli cinque anni.
Secondo il rapporto, gli incidenti critici sono aumentati dal 47\% all'81\% del totale e,
in Italia, il 58\% degli attacchi è costituito da malware, phishing e social engineering.

Con il recente e rapidissimo sviluppo dell' \gls{AI} il campo dell'Internet Filtering ha subito un vera e propria rivoluzione.
I nuovi modelli di Machine Learning sono capaci di analizzare e identificare con precisione siti malevoli,
grazie anche ai giganteschi volumi di dati di cui dispongono.
Questi sistemi riescono a riconoscere tecniche di phishing e malware avanzate, anche quando progettate per eludere i metodi di rilevamento tradizionali.

Questa tesi si colloca in questo contesto e si propone l'obiettivo di sviluppare un software prototipale per il filtraggio internet sul computer di installazione.
Il lavoro illustrerà dettagliatamente tutte le fasi di analisi, progettazione e sviluppo del progetto.

Data la necessità di interazione con componenti specifici del sistema operativo,
il software è stato sviluppato esclusivamente per Windows, con l'obiettivo di creare un servizio di sistema.

\section*{Struttura della Tesi}

La tesi si articola in 4 capitoli principali, che descrivono le diverse fasi della realizzazione del progetto, in particolare:



\begin{itemize}

    \item \textbf{Capitolo 1 (Contesto)}: in questo capitolo si tratta in maniera approfondita il problema affrontato dalla tesi.
    Viene analizzato il software attualmente presente in FlashStart e le motivazioni che inducono alla necessità di un nuovo sviluppo.
    
    \item \textbf{Capitolo 2 (Requisiti)}: in questo capitolo vengono affrontati casi d'uso e requisiti, analizzando il funzionamento e la percezione del progetto dal punto di vista dell'utente.
    
    \item \textbf{Capitolo 3 (Tecnologie)}:
    in questo capitolo vengono riportate le diverse tecnologie utilizzate e le scelte che hanno portato al loro impiego nel progetto.
    
    \item \textbf{Capitolo 4 (Analisi e progettazione)}:
    in questo capitolo viene descritta la fase di analisi e progettazione del sistema,
    illustrandone in particolare l'architettura e i pattern utilizzati, evidenziando in che modo il software ne tragga guadagno.

\end{itemize}

\mainmatter

%---------------------------------------------------
% CAPITOLO 1
%---------------------------------------------------
\chapter{Contesto}
\label{chap:contesto}

\section{Internet Filtering}

Il caso di studio oggetto di questa tesi è un software prototipale, che si inserisce nell'ambito dell'Internet Filtering.
Per Internet Filtering si intende un sistema di monitorazione, controllo e limitazione dell'accesso alle risorse online, basato su criteri predefiniti.

Una tecnologia di questo tipo risulta particolarmente utile ad aziende, scuole ed enti pubblici.
Tramite questa pratica è infatti possibile effettuare controlli sul contenuto delle pagine web, limitando o impedendo l'accesso a siti contenenti malware o, eventualmente, contenuti indesiderati (ad esempio siti di scommesse, pornografia, droghe...).
Risulta evidente fin da subito che, per garantire un filtraggio di contenuti preciso ed efficace, sia necessaria un'attenta analisi delle pagine web, evitando di correre il rischio di impedirne immotivatamente l'accesso.

Questa tesi è svolta come progetto in collaborazione con FlashStart, leader italiana per quanto riguarda il filtraggio \gls{DNS}.
Un server \gls{DNS} è un sistema che permette di tradurre nomi di domini leggibili da un uomo, in indirizzi interpretabili da dei computer per connettersi tra loro.
Il filtraggio si basa proprio su questo principio: quando si accede ad un sito web attraverso un browser qualsiasi, il computer interrogherà un server \gls{DNS} per ottenere l'indirizzo attraverso cui sia possibile accedere al sito.
Con un'apposita configurazione, si può indurre il \gls{DNS} a bloccare la risoluzione di pagine web malevoli o riportanti contenuti non graditi.
FlashStart offre un servizio \gls{DNS} configurabile, attraverso cui è possibile definire delle categorie di contenuti da bloccare.
I server dell'azienda aggiornano continuamente la lista delle categorie bloccate, facendo largo uso di \gls{AI} per garantire rapido aggiornamento (in risposta alla nascita di nuovi siti) ed alta precisione.
Quando un utente, utilizzando un computer protetto dal servizio di FlashStart, tenta di accedere ad un sito appartenente ad una delle categorie bloccate, il \gls{DNS} risponderà alla richiesta di risoluzione del nome con l'indirizzo di una pagina indicante i motivi del blocco, al posto di quella richiesta.

\section{Obiettivi del Progetto}
\label{sec:obiettivi-progetto}

Il filtraggio \gls{DNS} può essere implementato in diverse modalità, di seguito le principali:

\begin{itemize}
	\item \textbf{A livello di rete:} applicato direttamente dall'\gls{ISP}\footnote{
		Un \gls{ISP} è un fornitore che offre connettività alla rete, consentendo ai suoi utenti di accedere a Internet. Gli ISP possono anche fornire servizi aggiuntivi, come, appunto, sicurezza informatica e filtraggio.}, blocca l'accesso a domini malevoli prima che le richieste raggiungano la rete locale.  
	\newline \textit{Esempio: un'azienda utilizza un servizio \gls{DNS} filtrato fornito dal proprio \gls{ISP} per impedire l'accesso a siti malevoli su tutta la rete aziendale.}
	
	\item \textbf{A livello di router:} il router funge da punto di controllo, utilizzando un server DNS con filtraggio per impedire l'accesso a contenuti non autorizzati. Tutti i dispositivi connessi alla rete collegata al router beneficiano automaticamente della protezione.
	\newline \textit{Esempio: un istituto scolastico configura il proprio router con un DNS appositamente configurato per impedire l'accesso a siti per adulti e social network bloccandoli per gli studenti.}
	
	\item \textbf{A livello di endpoint:} il filtraggio DNS è applicato direttamente sui dispositivi tramite configurazione manuale o software specifici, garantendo protezione anche fuori dalla rete aziendale o domestica.  
	\newline \textit{Esempio: un dipendente che lavora da remoto utilizza un client DNS sicuro sul proprio laptop per proteggersi dalle minacce.}
\end{itemize}

FlashStart offre prodotti per tutte le suddette modalità, tuttavia questo progetto prende in esame soltanto la terza tipologia di protezione \gls{DNS}, ossia il filtraggio a livello di endpoint.
Nel periodo tra il 2019 e il 2021 le aziende italiane, così come quelle di tutto il mondo, hanno dovuto affrontare la necessità dell'impiego del lavoro remoto.
Se da una parte tale pratica rappresenta un'opportunità per i lavoratori, che ne guadagnano in flessibilità, dall'altra espone l'azienda a nuovi rischi.
A dimostrazione di ciò, proprio nel 2020 è stato emanato dall'\gls{AGID} il vademecum \cite{AgID2020}, cioè una serie di undici raccomandazioni che offrono linee guida per garantire la sicurezza del lavoro da remoto.

In effetti, un dispositivo che esce dall'azienda, ambiente potenzialmente controllato e protetto, diventa un rischio.
Un dipendente potrebbe involontariamente navigare in siti di phishing e malware o connettersi a reti Wi-Fi infette, esponendo l'azienda al rischio di furti o compromissione di dati.
Obiettivo fondante di questa tesi è lo sviluppo di un software facilmente installabile su un computer Windows, che consenta una protezione efficace e completa ai dispositivi desktop che escono dalla rete aziendale.
Tale progetto dovrà filtrare la connessione dell'endpoint remoto, bloccando l'accesso a siti pericolosi, come virus e frodi, ma anche a contenuti indesiderati e distrazioni sul lavoro, come social network o videogiochi.

\section{Contesto Aziendale}

FlashStart offre già un software di protezione da malware e contenuti indesiderati dedicato ad endpoint remoti: ClientShield.
Tale prodotto rappresenta un'estensione del filtro aziendale, fornendo lo stesso tipo di protezione, configurabile attraverso la medesima piattaforma cloud da parte di un amministratore di rete.

Allo stato dell'arte il prodotto utilizza una \gls{VPN}, per stabilire una comunicazione sicura con i server di FlashStart.
Ciò garantisce che il dispositivo possa inviare e ricevere non soltanto le informazioni sul prodotto, ma anche richieste \gls{DNS}, generalmente trasmesse in chiaro, in modo totalmente criptato.

L'esigenza di aggiornamento del software deriva dalla volontà di FlashStart di integrare il protocollo \gls{DoH}, descritto in \cite{RFC8484}, nei suoi prodotti.
Rispetto ad una classica \gls{VPN}, \gls{DoH} sfrutta la crittografia asimmetrica, implementata dal protocollo \gls{HTTPS}, per garantire autenticazione, confidenzialità e integrità delle richieste \gls{DNS}.

Il vantaggio che FlashStart trae da entrambi i protocolli è essenzialmente il medesimo: proteggere le comunicazioni \gls{DNS} tramite la crittografia, evitando la possibilità di attacchi dovuti alla trasparenza delle informazioni.
La differenza principale tra i due approcci è che una \gls{VPN} cripta il traffico di rete nella sua interezza, mascherando anche l'indirizzo IP del dispositivo, mentre \gls{DoH} si concentra esclusivamente sulla protezione delle richieste \gls{DNS}.

Per un'azienda come FlashStart, specializzata in filtraggio \gls{DNS}, mascherare l'indirizzo IP di un endpoint non è una funzionalità totalmente rilevante per l'erogazione del suo servizio.
L'adozione del protocollo \gls{DoH} consente quindi di ottenere la riservatezza necessaria per la comunicazione con il \gls{DNS}, eliminando la necessità di un'infrastruttura \gls{VPN} dedicata e riducendo l'overhead complessivo del sistema.

La novità principale del software prototipale illustrato in questa tesi, è dunque quella di fornire una soluzione per la transizione dalla tecnologia \gls{VPN}, all'adozione del protocollo \gls{DoH}.
Di fondamentale importanza è inoltre l'analisi e la valutazione di soluzioni architetturali atte a garantire la naturale evoluzione del software, facilitando l'introduzione di nuove funzionalità.


%---------------------------------------------------
% CAPITOLO 2
%---------------------------------------------------

\chapter{Analisi dei Requisiti}
\label{chap:analisi-dei-requisiti}

\section{Scopo del sistema e analisi del dominio}

L'analisi del dominio è un punto chiave per quanto riguarda lo sviluppo software.
Tale fase permette di comprendere il contesto in cui il software opera, gli attori principali ed i loro scopi.
In questo progetto l'analisi del dominio è risultata molto rapida e diretta, in quanto il prodotto è stato sviluppato con un'azienda del settore informatico, permettendo fin da subito l'utilizzo di un linguaggio tecnico.

Come già introdotto nella sezione \ref{sec:obiettivi-progetto}, il contesto in cui opera l'applicazione è quello della sicurezza informatica.
Il fine ultimo di ClientShield è di fornire una soluzione di filtraggio \gls{DNS} avanzata, che consenta un'efficace protezione ad un dispositivo che naviga al di fuori di una rete protetta.
L'interazione col software coinvolgerà in particolare:

\begin{itemize}
	\item \textbf{Utente finale:} cioè l'utilizzatore del dispositivo da proteggere, il quale navigherà normalmente in internet, utilizzando un browser ed inviando naturalmente richieste \gls{DNS}.
	
	\item \textbf{Amministratore di rete:} il cliente FlashStart, responsabile dell'installazione e configurazione del software sul dispositivo attraverso la chiave fornita sulla piattaforma cloud. 
	Tramite l'applicativo online potrà gestire le policy di filtraggio, aggiungendo o rimuovendo siti specifici o intere categorie di contenuti da bloccare.

	\item \textbf{Server FlashStart:} riceveranno le richieste \gls{DNS} effettuate dal dispositivo protetto e le risolveranno applicando i filtri configurati dall'amministratore di rete.
\end{itemize}
Il software dovrà operare in modo tale da rendersi completamente trasparente all'utente finale, il quale non dovrebbe percepire alcuna differenza durante la normale navigazione.

\section{Requisiti funzionali}

Il progetto prevede lo sviluppo di un'implementazione prototipale, ciò implica che le funzionalità del software trattate in questa tesi rappresentino un sottogruppo delle capacità che dovrà avere il sistema.
Tuttavia, poiché il risultato dello studio mira a gettare delle solide basi per una futura implementazione business di ClientShield, di seguito verranno elencati i requisiti del software nella sua interezza.
Una visione complessiva, infatti, permette di valutare fin da subito la possibilità di una futura integrazione delle funzioni aggiuntive, consentendo un'analisi più efficace.

Nella sua implementazione prototipale, ClientShield dovrà:

\begin{itemize}
	\item \textbf{Redirezionare le richieste \gls{DNS}:}
	l'applicazione catturerà tutto il traffico \gls{DNS} del dispositivo su cui è installata.
	Tutte le richieste devono essere redirezionate ai server FlashStart, sfruttando il protocollo \gls{DoH}.
	La risoluzione dei domini deve essere effettuata dai server aziendali, ClientShield agirà da client \gls{DoH}, facendo in modo di impedire la possibilità di \gls{DNS} leak\footnote{\textbf{DNS leak} si verificano quando le richieste \gls{DNS} non sono cifrate e vengono trasmesse in chiaro.  
		In questa condizione, un attaccante o qualsiasi entità che intercetti il traffico può monitorare i siti visitati dall'utente, compromettendo la privacy della navigazione.}.

	
	\item \textbf{Permettere la registrazione di un dispositivo localmente:}
	dopo l'installazione del software, chiunque disponga di una valida chiave di registrazione, può registrare il dispositivo.
	Per effettuare tale operazione saranno richiesti:
	\begin{itemize}
		\item \textit{chiave di registrazione:} ottenibile tramite un profilo cloud con la corretta licenza.
		\item \textit{nome del dispositivo:} una qualsiasi stringa che faciliti l'identificazione dell'endpoint ad un amministratore di rete.
	\end{itemize}
	Al termine della fase di registrazione, se avvenuta con successo, la protezione dovrà essere attivata e il dispositivo sarà visibile sulla piattaforma cloud.
	
	
	\item \textbf{Abilitare/disabilitare la protezione localmente:}
	accedendo all'applicazione, qualora la protezione sia disattivata, si dovrà offrire la possibilità di attivarla.
	Viceversa, se la protezione è attiva, l'utente avrà la possibilità di disattivarla inserendo un PIN.
	Tale codice è un numero intero presente sulla piattaforma cloud e dunque visualizzabile soltanto da un amministratore di rete.
	
	\item \textbf{Controllare lo stato:}
	l'applicazione dovrà periodicamente connettersi ai server FlashStart per verificare lo stato della protezione.
	Questa operazione nell'implementazione prototipale ha la funzione di verificare che il dispositivo sia ancora registrato sul cloud.
	La cancellazione dell'endpoint attraverso la piattaforma cloud, determinerà la disattivazione della protezione e la richiesta di una nuova registrazione.
	
	\item \textbf{Attivarsi automaticamente al riavvio:}
	se l'endpoint è già stato registrato, l'applicazione dovrà garantire il corretto funzionamento della protezione anche al riavvio.
	Ciò vuol dire che, all'accensione del dispositivo non dovrà essere necessaria, una nuova registrazione.
	ClientShield ricorderà le credenziali attive prima dello spegnimento, riattivando automaticamente la protezione all'accensione con le stesse.
	
\end{itemize}
Queste funzionalità costituiscono il complessivo comportamento del prototipo sviluppato in questo progetto.
L'obiettivo essenziale è dunque garantire la protezione del dispositivo, fungendo da intermediario tra l'endpoint e i server di FlashStart.
Con lo scopo di descrivere in modo semplice l'interazione tra utente, ClientShield e server \gls{DNS} FlashStart è stato realizzato il diagramma in figura \ref{fig:interazione-utente-software-server}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{figures/schema-utente-software-server.png}
	\caption{interazione tra utente, software e server FlashStart}
	\label{fig:interazione-utente-software-server}
\end{figure}

Come precedentemente anticipato, la versione business dell'applicazione garantirà una serie di funzioni minori in più, di seguito riportate:

\begin{itemize}
	
	\itemdef{Blocco remoto della protezione:}
	deve essere possibile disattivare la protezione da remoto, questa funzione può essere utilizzata sia dall'amministratore di rete, attraverso la piattaforma cloud, sia direttamente dai server FlashStart.
	Durante i controlli di stato periodici, infatti, verrà verificata la validità della licenza e, se non risultasse valida, la protezione verrà disattivata automaticamente, impedendo qualsiasi tentativo di riattivazione locale.
	
	\itemdef{Invio di notifiche:}
	durante la registrazione sarà possibile decidere di ricevere alcune notifiche dall'applicazione.
	Se attivate, il dispositivo riceverà soltanto le notifiche riguardanti lo stato della protezione del dispositivo, ad esempio licenza scaduta o disabilitazione remota.
	
	\itemdef{Applicazione unbranded:} 
	l'applicazione prima della registrazione dovreb-be avere un nome generico e non presentare alcun logo.
	Dopo la registrazione dovrà essere possibile ottenere informazioni sull'acquirente, come il nome scelto per il software e il logo da applicare.
	L'interfaccia grafica dell'applicazione dovrà adattarsi alle informazioni ottenute durante la registrazione.
	
	\itemdef{Controllo di stato periodico:}
	questa operazione è già presente in parte nell'implementazione prototipale, tuttavia nello sviluppo business dovrà reperire più informazioni.
	I dati supplementari, come ad esempio:
	\begin{itemize}
		\item informazioni sul blocco remoto
		\item nome e logo dell'acquirente
		\item cambio di impostazioni sulle notifiche
	\end{itemize}
	permetteranno l'implementazione delle funzionalità aggiuntive sopra riportate.

\end{itemize}
Come si può notare, le funzionalità business rappresentano più che altro un'estensione di funzioni già presenti nel modello prototipale.
Con una corretta analisi del software, dunque, dovrebbe essere possibile aggiungere tutte le funzionalità supplementari al sistema descritto in questa tesi senza particolari sforzi.

\section{Requisiti non funzionali}

Dopo aver definito in dettaglio \textit{cosa} deve fare ClientShield, è altrettanto importante stabilire \textit{come} debba farlo.
Oltre ai requisiti funzionali del sistema, infatti, il progetto prevede anche dei requisiti non funzionali, che mirano a garantire un livello qualitativo adeguato al sistema.
Questa categoria di requisiti ha l'obiettivo di soddisfare un potenziale cliente.
L'aderenza ad essi dovrebbe trasmettere la professionalità di FlashStart, garantendo un'esperienza di utilizzo piacevole per gli utilizzatori finali.

\subsection*{Semplicità}

Di fondamentale importanza è rendere il sistema semplice: rapido da installare e facile da configurare.  
FlashStart ha esplicitamente sottolineato quanto questo requisito sia cruciale per garantire la qualità del software.
La richiesta è naturalmente intuitiva: un'installazione e una configurazione rapide non solo migliorano l’esperienza dell’utente, ma rendono il software più facilmente integrabile nei diversi contesti aziendali.  
L'automatizzazione completa del processo di installazione consente agli amministratori di rete di implementare ClientShield senza difficoltà, ottimizzando i tempi e riducendo il rischio di errori nella configurazione.  

\subsection*{Efficienza}

Anche nello sviluppo prototipale, ClientShield dovrebbe garantire un'efficienza tale da risultare totalmente trasparente all'utente.
L'obiettivo è limitare qualsiasi impatto sulla navigazione, un utente qualsiasi del dispositivo dovrebbe potersi scordare della presenza di un filtro.
Ciò implica una rapida gestione delle richieste \gls{DNS}, consentendo una veloce risoluzione dei domini, limitando di conseguenza i tempi di caricamento delle pagine web.

Questo requisito è favorito dall'abbandono dell'utilizzo di una \gls{VPN} in favore del protocollo \gls{DoH} e dalla velocità generale dei server di FlashStart, che, a febbraio 2025, risulta essere il \gls{DNS} più veloce al mondo secondo \cite{DNSPerf2025}.

\subsection*{Resilienza}

Per garantire la corretta protezione del dispositivo, il servizio di filtraggio dovrebbe poter essere disattivato esclusivamente da un amministratore del dispositivo.
Ciò vuol dire che ClientShield dovrà assicurare il funzionamento continuo della protezione in qualsiasi condizione, anche nel caso in cui l'utente tenti di disattivare il filtro.
È requisito essenziale per il software fare in modo che nessuna operazione effettuata da utenti senza privilegi amministrativi, come il banale cambio di rete, possa interrompere la protezione.

\section{Casi d'uso}
\label{sec:casi-d-uso}

Allo scopo di descrivere in modo dettagliato il comportamento atteso del software, vengono di seguito riportati anche i casi d'uso del sistema.
Ciascun caso d'uso rappresenta una specifica interazione tra gli attori e ClientShield, chiarificando le azioni che possono essere eseguite e le risposte da parte dell'applicazione.
Questa visione è particolarmente utile, perché pone l'attenzione sull'utente, evidenziando come interagirà con ClientShield e cosa percepirà in seguito ad ogni possibile azione eseguita.
Di seguito sono riportati i principali casi d'uso del prototipo:

\begin{itemize}
	
	\item \textbf{Utente avvia l'applicazione:}
	all'avvio dell'applicazione se il dispositivo non risulta registrato, l'utente verrà indirizzato ad una schermata di registrazione.
	Se invece l'utente è già registrato e la protezione è disattivata, allora verrà offerta la possibilità di attivarla.
	Viceversa, se è già registrato e la protezione è attiva, deve essere disponibile un'opzione per disattivarla.
	
	\item \textbf{Registrazione:}
	per registrarsi l'utente dovrà inserire i campi richiesti (chiave di profilo e nome del dispositivo).
	Se la registrazione ha avuto successo la protezione deve essere attivata, iniziando subito a filtrare le richieste \gls{DNS}.
	Per la comunicazione con i server FlashStart sarà necessario un codice utente univoco, ottenibile come risposta alla fase di registrazione.
	In caso di errore, la causa deve essere visibile dall'utente, che potrà ritentare.
	
	\item \textbf{Disattivazione protezione:}
	per disattivare la protezione tramite l'applicazione sarà necessario l'inserimento di un codice PIN.
	Il PIN è un numero intero visualizzabile dalla piattaforma cloud e deve essere validato.
	Se il codice è corretto, la protezione viene disattivata; in caso contrario, sarà mostrato un messaggio di errore e l'utente potrà ritentare.
	
	\item \textbf{Utente riavvia il dispositivo:}
	al riavvio del computer, se l'endpoint era stato correttamente registrato prima dello spegnimento, la protezione deve essere automaticamente riattivata.
	ClientShield dovrà recuperare il codice univoco fornito in fase di registrazione, che sarà utilizzato, come sempre, per la comunicazione con i server FlashStart.
	
	\item \textbf{Utente naviga sul web:}
	la navigazione su un browser deve avvenire come di consueto.
	In caso di accesso ad un contenuto bloccato deve essere visibile una pagina di stop, che riporti le motivazioni del blocco.

\end{itemize}

Per riassumere le azioni che un utente può compiere in ciascun momento è stato realizzato la schema in figura \ref{fig:schema-casi-uso}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{figures/schema-casi-uso.png}
	\caption{navigazione dell'utente nell'app}
	\label{fig:schema-casi-uso}
\end{figure}

%---------------------------------------------------
% CAPITOLO 3
%---------------------------------------------------

\chapter{Analisi e progettazione}
\label{chap:analisi-e-progettazione}

\section{Struttura del progetto}

Lo sviluppo del progetto è stato naturalmente preceduto da una necessaria fase di analisi.
Identificati i requisiti del sistema, espressi nel capitolo \ref{chap:analisi-dei-requisiti}, risulta necessario definire come debba essere strutturato il software sulla base di essi.
Durante l'intera fase di progettazione si è tenuto conto del fatto che ClientShield ha come target di piattaforma Windows, in particolare a partire dalla versione 10.

Dall'analisi dei requisiti emerge chiaramente la presenza di due componenti ben distinti.
ClientShield, infatti, dovrà costantemente filtrare richieste \gls{DNS}, interagendo in maniera continuativa con il sistema operativo.
L'interazione diretta con l'utente, invece, è sporadica e avviene soltanto in caso di necessità, attraverso un'interfaccia grafica.
Per tale motivo, si è deciso fin da subito di suddividere lo sviluppo del software in due sotto-progetti, collegati tra loro, ma ben distinti.
Un'organizzazione di questo tipo permette di ottenere vantaggi importanti.

Anzitutto, la divisione in due sotto-progetti induce ad una minore complessità generale del sistema e ad una chiara suddivisione delle responsabilità.
Tale approccio, inoltre, da un punto di vista aziendale, facilita la gestione del codice e un'eventuale suddivisione del lavoro tra più sviluppatori.

In secondo luogo, sebbene il servizio di filtraggio debba necessariamente interagire con il sistema operativo, l'interfaccia utente e la logica di configurazione del filtro non hanno vincoli di piattaforma.
Ciò apre la possibilità ad una potenziale estensione multi-platform\footnote{La programmazione \textbf{multi-platform} si pone l'obiettivo di consentire allo stesso codice di poter essere eseguito su macchine aventi sistemi operativi differenti.} per la parte grafica.
Di conseguenza, un'eventuale espansione a sistemi operativi diversi (ad esempio Linux) richiederebbe unicamente la modifica del modulo di filtraggio.

\subsection{Organizzazione dei sotto-progetti}
\label{ssec:organizzazione-sotto-progetti}

Sulla base di questa suddivisione logica, ClientShield è stato organizzato in quattro diversi sotto-progetti:

\begin{itemize}
	\item \textbf{Servizio di filtraggio:}
	questo modulo rappresenta la parte centrale del software, sarà il responsabile dell'intercettazione e del filtraggio delle richieste \gls{DNS}.
	Dovrà essere implementato come servizio Windows, garantendo un'esecuzione continua e automatica all'avvio del sistema, definendo inoltre strategie di recupero in caso di errori.
	
	\item \textbf{Interfaccia utente:}
	questo modulo rappresenta la parte del software con cui l'utente interagirà.
	Il ruolo del sotto-progetto è di consentire la comunicazione con il servizio di filtraggio attraverso un'interfaccia grafica intuitiva.
	
	\item \textbf{Modulo comune:}
	questo modulo conterrà variabili, classi e configurazioni condivise tra interfaccia e servizio di filtraggio.
	Qui saranno specificati anche i tipi di messaggio che possono essere scambiati tra servizio e interfaccia, permettendo di mantenere sempre integrità di comunicazione tra i due sotto-progetti.
	
	\item \textbf{Installer:}
	questo modulo è dedicato alla creazione dell'installer del software.
	Si occuperà di automatizzare l'installazione del servizio e dell'interfaccia, garantendone il funzionamento corretto.
\end{itemize}
L'organizzazione del progetto finale seguirà il più possibile la struttura illustrata in figura \ref{fig:struttura-directory-clientshield}.

\begin{figure}[H]
	\centering
	\begin{forest}
		pic dir tree,
		pic root,
		for tree={% folder icons by default; override using file for file icons
			directory,
			fit=band
		},
		[FlashStart/
		[ClientShield/
		[Service/]
		[GUI/]
		[Common/]
		[Installer/]
		]
		]
	\end{forest}
	\caption{Struttura dei sotto-progetti di ClientShield}
	\label{fig:struttura-directory-clientshield}
\end{figure}

\section{Comunicazione interprocesso}

Vista la divisione in progetti separati, la successiva fase di analisi ha preso in considerazione la modalità di comunicazione tra i due progetti.
L'architettura generale di ClientShield assomiglia molto ad un sistema client-server.
Infatti, l'interfaccia grafica deve stabilire una connessione con il servizio Windows per inviare dei messaggi contenenti gli input dell'utente e la richiesta di svolgere determinate operazioni, per poi attendere la risposta del servizio.

Per permettere la corretta comunicazione tra il servizio Windows e l'interfaccia grafica, è necessario stabilire un protocollo di comunicazione inter-processo.
Le caratteristiche fondamentali di tale protocollo sono garantire una comunicazione affidabile e di tipo half-duplex\footnote{La comunicazione \textbf{half-duplex} tra due nodi permette la trasmissione di messaggi da parte di entrambi, ma soltanto uno per volta.} tra due processi separati, ma in esecuzione sullo stesso dispositivo.

Per la scelta del protocollo, dovendo sviluppare in ambiente Windows, ci si è riferiti alla documentazione Microsoft, che presenta l'articolo \cite{MicrosoftIPC2024} sulle comunicazioni inter-processo.
Si è optato per l'utilizzo della comunicazione tramite named pipes, consigliata soprattutto per la sua affidabilità e semplicità di implementazione, grazie al supporto nativo offerto da Windows.

Le named pipes permettono di stabilire un canale di comunicazione identificato da un nome univoco, accessibile sia dal servizio che dall'interfaccia senza necessità di configurazioni complesse.   
Un ulteriore vantaggio è la loro efficienza: essendo ottimizzate per la comunicazione all'interno dello stesso sistema, garantiscono una latenza ridotta rispetto ad altre tecniche di comunicazione inter-processo.  
Infine le named pipes offrono la possibilità di definire controlli di accesso a livello di sistema operativo, impedendo la manipolazione dei dati da parte di processi non autorizzati, garantendo che solo l'interfaccia ufficiale possa inviare comandi al servizio, evitando interferenze da applicazioni di terze parti.

Scelto il protocollo, si è scelta la struttura dei messaggi.
Vista la vasta disponibilità di librerie capaci di serializzare e deserializzare classi in formato JSON, si è deciso di utilizzare quest'ultimo per la comunicazione.
La scelta è dovuta al fatto che i dati presenti nel messaggio dipendono dall'operazione e possono essere anche di tipo diverso. Infatti la disabilitazione, come sottolineato in sezione \ref{sec:casi-d-uso}, necessita l'inserimento di un numero intero.
Ciò significa che l'invio di semplici stringhe di testo richiederebbe controlli manuali sulla struttura del messaggio e sui tipi di ogni singolo campo.
JSON permette l'automatizzazione dei controlli: sarà sufficiente definire delle classi rappresentanti i diversi tipi di messaggio nella comunicazione e delegare la conversione da classe a JSON, o viceversa, ad una libreria esterna, gestendo eventuali errori.

In figura \ref{fig:schema-messaggi-gui-service} viene illustrato il possibile scambio di messaggi tra interfaccia grafica e servizio Windows.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{figures/schema-messaggi-gui-service.png}
	\caption{Scambio di messaggi tra GUI e servizio Windows}
	\label{fig:schema-messaggi-gui-service}
\end{figure}

\section{Servizio Windows}

Il servizio di filtraggio si compone essenzialmente di due parti: una gestisce la comunicazione inter-processo, l'altra si occupa del filtraggio \gls{DNS}.
Dei due componenti, la comunicazione inter-processo deve essere sempre disponibile, ma il servizio di filtraggio si potrà attivare e disattivare a comando.
Per questo motivo, il servizio Windows deve essere costituito principalmente come un server named pipe, mentre l'analisi si concentra sull'organizzazione del servizio di protezione.

Nel vecchio software, per assicurare che tutto il traffico passasse dal filtro, veniva creata una scheda di rete virtuale.
Modificando le metriche di priorità delle interfacce si rendeva quest’ultima la più “alta in graduatoria”, così che il sistema instradasse il traffico su di essa prima di qualsiasi altra. Questo permetteva di intercettare le richieste e bloccare o modificare il traffico indesiderato. Tuttavia, si trattava di una soluzione più complessa da gestire e potenzialmente soggetta a conflitti con altri driver o componenti di rete.

Nella nuova versione di ClientShield, invece, si è deciso di implementare un server \gls{DNS} locale, soluzione che offre dei vantaggi considerevoli:

\begin{itemize}
	\item \textbf{Semplicità di implementazione:}
	configurare un processo che ascolti sulla porta 53 e risolva le richieste \gls{DNS} è decisamente più semplice rispetto alla creazione di una scheda di rete virtuale.
	Tale scelta, inoltre, limita anche il rischio di incompatibilità con software terzi che gestiscono altre schede di rete virtuali.
	
	\item \textbf{Manutenibilità:}
	un server locale consente di isolare la responsabilità del software semplicemente al filtraggio.
	Questa soluzione permette una maggiore chiarezza e una più corretta aderenza al \gls{SRP}. %, descritto in \cite{Martin2002}.
	In questo modo, infatti, il modulo di protezione gestisce solo richieste \gls{DNS}, migliorando il debugging, che sarà limitato ad un singolo componente.
	
	\item \textbf{Portabilità:}
	l'implementazione di un server \gls{DNS} non ha dipendenze specifiche dal sistema operativo.
	Le soluzioni esplorate in seguito consentono di relegare l'interazione diretta con il sistema operativo alla sola impostazione del server locale come \gls{DNS} predefinito.
\end{itemize}

In sintesi, il nuovo design del servizio Windows prevede l'implementazione di un server named pipe che, su comando dell'utente, interagisca con il servizio di protezione per avviare l'esecuzione di un server \gls{DNS} locale, impostandolo come predefinito di sistema, oppure interromperla.

\subsection{Analisi della protezione}
\label{ssec:analisi-protezione}

L'avvio della protezione è un problema più complesso di quanto possa sembrare.
Per attivarla è necessaria l'interazione con molti componenti del sistema.
Il server named pipe dovrebbe gestire le API FlashStart, occupandosi della registrazione, dell'autorizzazione e dei controlli periodici sullo stato del servizio.
Inoltre, deve monitorare lo stato del server \gls{DNS} e interagire con esso, permettendone il riavvio e l'arresto automatici o su richiesta. 
In aggiunta, il servizio deve occuparsi anche della gestione delle credenziali, memorizzando il codice utente fornito durante la registrazione e garantendo il ripristino della sessione al riavvio del dispositivo.

Per una corretta delegazione delle responsabilità e per ottenere semplicità nella comunicazione con diversi componenti, è stato sfruttato il pattern \textit{Facade}, definito in \cite{GoF94}.
Questo pattern fornisce una semplice interfaccia che consente la gestione di funzionalità distribuite su più classi.

Dalla struttura delle classi, illustrata in figura \ref{fig:protezione-facade-pattern}, è possibile constatare che la classe \texttt{ServerNamedPipe} si occupa esclusivamente di ricevere ed elaborare le richieste da parte del client, delegando l'esecuzione di qualsiasi operazione alla classe \texttt{ProtectionManager}.
Quest'ultima funge da punto di raccordo tra le diverse funzionalità offerte dal software, gestendole in maniera organizzata, permettendo una granularità maggiore che facilita la manutenzione del codice.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/protezione-facade-pattern.png}
	\caption{Facade pattern per la gestione della protezione}
	\label{fig:protezione-facade-pattern}
\end{figure}
\texttt{ProtectionManager} coordina l'esecuzione delle funzionalità offerte dalle classi gestite, consentendo una gestione implicita delle credenziali affidata completamente a \texttt{CredentialManager}.
Inoltre, \texttt{ProtectionManager} verifica costantemente la coerenza tra lo stato dei componenti e, se presente una sessione attiva, avvia automaticamente la protezione.


\subsection{Analisi server DNS}
\label{ssec:analisi-server-dns}

Il server \gls{DNS} locale rappresenta il nucleo centrale di ClientShield, poiché gestisce sia la risoluzione dei domini che l'applicazione dei filtri.
Per garantire flessibilità ed estensibilità, il server è stato suddiviso in più componenti, ciascuno con una funzionalità specifica.
La scelta è motivata da due fattori principali.
In primo luogo, suddividere il server in componenti più piccoli ne facilita l'estensibilità, consentendo di aggiungere nuove funzioni senza alterare la struttura di base.
Inoltre, la suddivisione delle funzionalità consente il più facile impiego di thread-pools, consentendo la creazione di worker sulla base dei componenti.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/dns-strategy-pattern.png}
	\caption{Strategy pattern per Server DNS}
	\label{fig:dns-strategy-pattern}
\end{figure}
Come illustrato in figura \ref{fig:dns-strategy-pattern}, \texttt{ServerDns} utilizza il pattern \textit{Strategy} per la risoluzione dei domini.
Delegando la risoluzione dei domini a una classe secondaria, \texttt{DnsResolver}, è possibile implementare tecnologie differenti.
Sebbene i requisiti del prototipo richiedano la sola implementazione \gls{DoH}, FlashStart ha già implementato delle API che utilizzano il protocollo \gls{DoT}.
Se in futuro l'azienda decidesse di adottare \gls{DoT} o un qualsiasi altro tipo di tecnologia per la risoluzione dei domini, sarà sufficiente sostituire il \texttt{DnsResolver} con un'implementazione specifica, senza modificare il resto del sistema.


Un altro aspetto fondamentale riguarda la gestione delle richieste in ingresso.  
Poiché la porta 53, dedicata alla comunicazione \gls{DNS}, può essere gestita da un solo componente alla volta, la ricezione dei pacchetti è affidata alla classe \texttt{SocketListener}. 
Tale entità ha il compito di minimizzare i tempi di gestione delle query in arrivo, prevenendo la perdita di richieste.
Per massimizzare l'efficienza, \texttt{SocketListener} utilizzerà una coda di messaggi, permettendo alla classe \texttt{ServerDns} di elaborare le richieste in parallelo.
Se necessario, potranno essere utilizzati worker dedicati per ottimizzare le prestazioni e garantire l'elevata reattività del sistema.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/dns-decorator-pattern.png}
	\caption{Decorator pattern per Server DNS}
	\label{fig:dns-decorator-pattern}
\end{figure}
Infine, l'ultimo e cruciale compito affidato al servizio Windows è impostare il server \gls{DNS} locale come predefinito di sistema.
Questa fase è decisamente delicata, perché rappresenta il punto in cui ClientShield interagisce direttamente con il sistema operativo, diventando di fatto dipendente dalla piattaforma.

La soluzione utilizzata in questo caso, illustrata in figura \ref{fig:dns-decorator-pattern}, sfrutta il pattern \textit{Decorator}.
Questa scelta permette di isolare la logica di interazione con Windows in una classe secondaria, migliorando il riuso.
Ad interagire con il sistema operativo è la classe statica \texttt{NetworkManager}, che consente di configurare il \gls{DNS} di sistema come statico, specificando un indirizzo, oppure di ripristinarlo in modalità dinamica.
Il decoratore \texttt{StubbornDnsServer} permette di aggiungere le funzionalità di \texttt{NetworkManager} a \texttt{ServerDns}.
In questo modo è possibile estendere i metodi per avviare e interrompere il server, garantendo, rispettivamente, l'aggiornamento e il ripristino automatico del \gls{DNS} predefinito sul dispositivo.
L'adozione del pattern \textit{Decorator} risulta particolarmente utile, in quanto consente di isolare l'utilizzo di librerie specifiche per Windows a due sole classi, aprendo la possibilità ad un futuro sviluppo multi-platform.

\section{Interfaccia grafica}

L'interfaccia grafica è l'unica parte del software con cui l'utente interagirà direttamente.
Il suo compito è essenzialmente quello di permettere all'utilizzatore l'accesso ai comandi della protezione, esposti tramite il server pipe dal servizio Windows.
L'interfaccia agisce come client nella connessione tramite named pipe, inviando le richieste effettuate dall'utente e attendendo la risposta dal server.

Poiché il software è soltanto un prototipo, l'obiettivo dell'analisi è proporre una soluzione che permetta una facile modifica della parte visiva.
L'interfaccia sarà sviluppata molto semplicemente, dando solo una rapida rappresentazione grafica ai comandi che è possibile effettuare.
Dal punto di vista aziendale, il prototipo risulta efficace se la modifica dell'interfaccia, che verrà senza dubbio sottoposta al consiglio di grafici esperti, richiede poche o nulle modifiche di backend.

\subsection{Model-View-Presenter}

Per lo sviluppo dell'interfaccia grafica è stato utilizzato il pattern architetturale \textit{\gls{MVP}}.
\gls{MVP} è un'architettura software che deriva dal famosissimo pattern \textit{\gls{MVC}}, nata con lo scopo di separare la logica di presentazione dall'interfaccia, in modo da migliorare la manutenibilità e il testing del codice.

Si compone di tre elementi principali:
\begin{itemize}
	\itemdef{Model:}
	offre un'interfaccia per reperire i dati che devono essere visualizzati, l'ottenimento dei quali può coinvolgere eventualmente anche la comunicazione tramite API.
	
	\itemdef{View:}
	è la parte responsabile della rappresentazione dei dati.
	La \textit{View} si occupa esclusivamente di eseguire chiamate al suo \textit{Presenter} ogni qual volta l'utente interagisca con l'interfaccia.
	Tipicamente è un componente totalmente passivo, le cui funzionalità sono ridotte al minimo e contengono poca, o nessuna logica.
	Non comunica direttamente con la parte di \textit{Model}, tutti i dati passano attraverso il \textit{Presenter}, lasciando alla \textit{View} il solo compito di rappresentarli visivamente.
	
	\itemdef{Presenter:} implementa l'intera logica di presentazione, occupandosi
	di reperire i dati dal \textit{Model} ed eventualmente modificarli in modo che
	possano essere rappresentati.
	Il \textit{Presenter}, inoltre, riceve i dati in input dalla \textit{View}, li valida e si occupa della loro elaborazione.
	Svolge il ruolo di mediatore tra \textit{Model} e \textit{View}, occupandosi di verificare sempre la coerenza tra dati e rappresentazione.
\end{itemize}
A causa della loro stretta interconnessione, Presenter e View detengono riferimenti reciproci, consentendo ad ognuno di chiamare i metodi dell'altro.
Ogni View necessita il suo specifico Presenter e tipicamente lo instanzia essa stessa.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/mvp-diagramma-sequenza.png}
	\caption{Diagramma di sequenza pattern MVP}
	\label{fig:mvp-diagramma-sequenza}
\end{figure}
In figura \ref{fig:mvp-diagramma-sequenza} è possibile visualizzare i componenti dell'architettura proposta, che trae ispirazione dell'articolo \cite{Ramsdale2010}.
L'immagine offre una rappresentazione delle interazioni che dovrebbero avvenire in una corretta implementazione dell'architettura.

Nell'interfaccia grafica di ClientShield non esiste un vero e proprio Model, i dati da rappresentare risultano essere gli stati della protezione.
Pertanto, a svolgere tale ruolo è \class{PipeClient}, che è il responsabile della comunicazione con il servizio Windows, dal quale ottiene risposte sull'esito delle operazioni e sullo stato della protezione.

Stando a quanto riportato in sezione \ref{sec:casi-d-uso}, le possibili \class{View} sono tre e rispecchiano gli stati di ClientShield: non registrato, protezione attiva, protezione disattivata.
Ognuna di esse dovrà avere il proprio \class{Presenter} che consenta di validare e processare i dati delle richieste utente.

L'architettura proposta sostituisce all'implementazione di una coda di eventi, utilizzata in \cite{Ramsdale2010}, l'utilizzo della classe \class{NavigationController}.
Quest'ultima si configura come un \textit{observer} per i \class{Presenter}, che notificano gli eventi scatenati dall'interfaccia grafica.
Tali eventi, che rappresentano tipicamente il passaggio da uno stato all'altro,  necessitano una visione globale sull'applicazione ed una gestione centralizzata, compito che, pertanto, non può essere svolto da un semplice \class{Presenter}.

%---------------------------------------------------
% CAPITOLO 4
%---------------------------------------------------

\chapter{Implementazione}

La successiva, ed ultima, fase del progetto ha riguardato lo sviluppo, che ha compreso la scelta delle tecnologie da utilizzare e l'effettiva scrittura di codice.
Questa fase è stata indubbiamente resa più veloce e diretta grazie all'attento lavoro di documentazione, analisi e progettazione descritto nei capitoli precedenti.

\section{Scelta del linguaggio}

Il linguaggio scelto per lo sviluppo di ClientShield è stato \cs con .NET 8.
Questa scelta è stata piuttosto naturale, sia perché è lo stesso linguaggio utilizzato dalla precedente implementazione di FlashStart, ma soprattutto grazie alle caratteristiche del linguaggio, che si adeguano perfettamente ai requisiti del software.
Innanzitutto \cs è un linguaggio moderno, che consente uno sviluppo ed una manutenzione più semplici, grazie alla sua sintassi chiara e funzionalità avanzate.
L'utilizzo di questo linguaggio garantisce un ottimo equilibrio tra efficienza e semplicità, garantendo una gestione automatica della memoria tramite la garbage collection\footnote{La \textbf{garbage collection} identifica e recupera automaticamente la memoria occupata da oggetti non più utilizzati, evitando che il programma esaurisca lo spazio disponibile.} ed una vasta disponibilità di librerie e framework che facilitano lo sviluppo.

Analogamente a Java, \cs supporta la programmazione multi-platform, ma risulta più adatto per ClientShield grazie alla perfetta integrazione dell'ecosistema .NET con Windows, che rappresenta il target principale del software.
\cs, infatti, ha accesso facilitato alle API di Windows grazie a librerie ufficiali sviluppate da Microsoft, che fornisce inoltre guide e documentazione utile all'implementazione e installazione di servizi Windows sviluppati in .NET. 

Il linguaggio supporta anche l'implementazione di interfacce utente native attraverso \gls{WPF}, che permette l'applicazione del pattern \gls{MVP} scelto in fase di analisi.
Inoltre la comunicazione tramite named pipes è supportata nativamente e vengono offerti diversi strumenti per la creazione di un installer.
Ciò consente l'uso del medesimo linguaggio per tutti i progetti definiti in sezione \ref{ssec:organizzazione-sotto-progetti}, garantendo coerenza nell'intera codebase, oltre a permettere una struttura assolutamente simile a quella prevista.

La scelta del linguaggio conduce all'ovvia adozione di Visual Studio come \gls{IDE}\footnote{Un \textbf{\gls{IDE}} è un software che fornisce strumenti come editor di testo, compilatori e debugger per facilitare la scrittura e la gestione del codice.}, che offre suggerimenti di codice, editor integrato di interfacce utente, ottimi strumenti di debugging, supporto per il version control di Git e tantissime altre funzionalità che lo rendono una scelta ottime per questo linguaggio.

La directory di ClientShield segue la struttura illustrata in figura \ref{fig:struttura-directory-clientshield}, è stata creata un'unica soluzione composta da tre dei quattro progetti previsti:
\begin{itemize}
	\item \textbf{Service:}
	è un progetto di tipo Worker Service, template presente in Visual Studio e adatto allo sviluppo di un servizio Windows.
	
	\item \textbf{Client:}
	è un progetto di tipo \gls{WPF}, adatto allo sviluppo di una moderna interfaccia grafica per sistemi Desktop.
	
	\item \textbf{Common:}
	questo progetto contiene i messaggi e le configurazioni della comunicazione inter-processo, utilizzabili sia da Service, che da Client.
\end{itemize}
L'installer non è stato sviluppato nella versione prototipale.

\subsection{Tecnologie di supporto}

\subsection*{NuGet}

Per lo sviluppo di ClientShield sono state utilizzate diverse librerie esterne, perciò, allo scopo di gestire le dipendenze del progetto, è stato utilizzato NuGet\footnote{Sito ufficiale NuGet: \url{http://nuget.org}}, il gestore di pacchetti ufficiale per l'ecosistema .NET.

NuGet permette di aggiungere, aggiornare e rimuovere pacchetti esterni con facilità, evitando la necessità di includere manualmente le librerie.
Ha un ruolo chiave nel processo di sviluppo, in quanto, grazie al controllo di versione sulle dipendenze, segnala problemi di incompatibilità tra le librerie di un progetto, evitando potenziali errori difficili da individuare manualmente.

\subsection*{Git}

Per lo sviluppo è stato fondamentale l'utilizzo di Git\footnote{Sito ufficiale di Git: \url{http://git-scm.com}}, un sistema di versionamento, che permette un efficace controllo sulle modifiche, consentendo di preservare l'integrità del codice.
Git è senza dubbio uno dei sistemi di versionamento più utilizzati, grazie alla capacita di gestire in modo molto efficiente anche progetti particolarmente complessi.

Il software consente di tenere traccia di ogni modifica apportata al codice, permettendo di ripristinare versioni precedenti in caso di errori o di confrontare diversi stati del progetto. Nel contesto di ClientShield, trattandosi di un prototipo sviluppato da zero, il lavoro si è concentrato prevalentemente su un unico branch principale, evitando la necessità di gestire rami multipli tipici di progetti più strutturati.
Per migliorare la leggibilità dello storico delle modifiche è stata adottata una struttura standardizzata per i commit, preceduti da tag identificativi che ne indicano il tipo: ad esempio i tag \texttt{[DOC]} per la documentazione o \texttt{[NEW]} per le nuove funzionalità.

Un ulteriore vantaggio di Git è la grande compatibilità con piattaforme cloud come GitHub\footnote{Sito ufficiale di GitHub: \url{http://github.com}}, consente di lavorare su computer diversi con codice sempre sincronizzato.

\subsection*{Librerie di gestione JSON}

In fase di analisi si è scelto di utilizzare JSON per la comunicazione inter-processo.
Tale scelta ha reso possibile l'utilizzo di un meccanismo di deserializzazione che avesse un modello di ereditarietà, in modo da poter effettuare un casting intelligente.

A tal scopo è stata utilizzata la libreria JsonSubTypes\footnote{Sito ufficiale JsonSubTypes: \url{http//manuc66.github.io/JsonSubTypes/}}, che consente di definire una classe base comune per tutte le richieste, semplificando la gestione dei messaggi.
Invece di trattare ogni richiesta come entità separata, il sistema utilizza un tipo di richiesta generico, che viene poi convertito in richieste specifiche, ad esempio di autorizzazione o registrazione.
Il controllo e la conversione da messaggio generico a specifico sono gestiti direttamente dalla libreria, eliminando la necessità di controlli manuali sulla struttura delle richieste e migliorando la pulizia del codice.

La serializzazione e la deserializzazione sono gestite attraverso la libreria Newtonsoft.Json\footnote{Sito ufficiale Newtonsoft.Json: \url{http://www.newtonsoft.com/json}}. Questa libreria è in grado di lavorare assieme a JsonSubTypes per la corretta conversione da classe a JSON e viceversa, offrendo semplicità, ottime prestazioni e individuazione automatica di errori di conversione.

\subsection{Implementazione progetto Service}

Il progetto per l'implementazione del servizio Windows è stato sviluppato a partire dalla guida \cite{MicrosoftServices2021} realizzata da Microsoft.
Il servizio è stato sviluppato, come suggerito dalla guida, attraverso un \class{BackgroundService} che, all'avvio, instanzia un \class{ServerNamedPipe} e un \class{ProtectionManager}, adeguatamente introdotti nella sezione \ref{ssec:analisi-protezione} ed illustrati in figura \ref{fig:protezione-facade-pattern}.

\paragraph{ServerNamedPipe} è una classe implementata facendo uso delle librerie di sistema, agisce da server per la comunicazione inter-processo.
Il server sarà sempre in ascolto sulla pipe di nome "FlashStart-ClientShield-Service-Pipe" finché il servizio Windows è attivo.
Il costruttore necessita il passaggio di un oggetto \class{ProtectionManager}, col quale il server si interfaccia per eseguire i comandi ricevuti dalla named pipe.

\paragraph{ProtectionManager} è una classe dedita alla gestione generale del servizio di protezione, garantendo il coordinamento tra la gestione delle credenziali, la comunicazione con le API FlashStart e l'esecuzione del server \gls{DNS} locale.
Questa classe funge da punto di raccordo tra le classi che offrono i suddetti servizi:
\begin{itemize}
	\itemdef{CredentialManager:} viene utilizzato all'instanziazione di {ProtectionManager} per controllare l'esistenza di un cliente già registrato.
	Durante le fasi di registrazione e logout questa classe di occupa di salvare o eliminare le credenziali sul dispositivo.
	
	\itemdef{FlashStartClient:} viene utilizzato durante tutta l'esecuzione del servizio per interfacciarsi con le API di FlashStart.
	
	\itemdef{StubbornDnsServer:} classe dedicata alla gestione del server \gls{DNS} locale, viene inizializzato da \class{ProtectionManager} all'avvio della protezione.
\end{itemize}

\paragraph {CredentialManager} utilizza il gestore di credenziali Windows per la memorizzazione del Client ID, cioè il codice utente univoco necessario per la comunicazione con i server FlashStart.
Questa classe è sviluppata come wrapper dell'omonimo modulo appartenente alla libreria Meziantou.Framework.Win32, gestendo automaticamente le configurazioni necessarie per consentire una più facile interazione da parte di \class{ProtectionManager}.
I metodi esposti consentono in particolare la registrazione, l'eliminazione, l'aggiornamento e la visualizzazione (se presente) del codice utente.\\

\paragraph{FlashStartClient} utilizza un client HTTP fornito dalle librerie di sistema per effettuare richieste ai server FlashStart, impostandone automaticamente l'header di autenticazione.
Questa classe espone metodi per permettere di effettuare le richieste di \textit{registrazione}, \textit{autorizzazione} e \textit{check}.

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter\

\bibliographystyle{alpha}
\bibliography{bibliography}

\begin{acknowledgements} % this is optional
Optional. Max 1 page.
\end{acknowledgements}

\end{document}